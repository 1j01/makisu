<html><head><base href="https://3dsushimulator.com/">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Sushi Simulator - Interactive Toolbar</title>
<style>
  body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
  }
  #scene-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  #ui-container {
    position: absolute;
    top: 10px;
    left: 10px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 10px;
    border-radius: 5px;
  }
  #toolbar {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.7);
    padding: 10px;
    border-radius: 5px;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  button {
    margin: 5px;
    padding: 5px 10px;
    font-size: 14px;
    cursor: pointer;
  }
  .toolbar-button {
    background-color: transparent;
    border: none;
    color: white;
    font-size: 24px;
    margin: 0 10px;
    cursor: pointer;
    transition: color 0.3s ease;
  }
  .toolbar-button:hover {
    color: #ffd700;
  }
  .toolbar-button.active {
    color: #ffd700;
  }
  #rice-counter, #nori-counter {
    margin-top: 10px;
    font-weight: bold;
  }
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
<div id="scene-container"></div>
<div id="ui-container">
  <button id="add-rice">Add Rice</button>
  <button id="add-nori">Add Nori</button>
  <button id="add-fish">Add Fish</button>
  <button id="roll-sushi">Roll Sushi</button>
  <div id="rice-counter">Rice grains: 0</div>
  <div id="nori-counter">Nori sheets: 0</div>
</div>
<div id="toolbar">
  <button id="camera-rotate" class="toolbar-button active" title="Rotate Camera"><i class="fas fa-sync-alt"></i></button>
  <button id="camera-pan" class="toolbar-button" title="Pan Camera"><i class="fas fa-arrows-alt"></i></button>
  <button id="camera-zoom" class="toolbar-button" title="Zoom Camera"><i class="fas fa-search"></i></button>
  <button id="interact-move" class="toolbar-button" title="Move Ingredients"><i class="fas fa-hand-paper"></i></button>
  <button id="interact-delete" class="toolbar-button" title="Delete Ingredients"><i class="fas fa-trash-alt"></i></button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
  let scene, camera, renderer, world, controls, raycaster, mouse;
  let timeStep = 1 / 60;
  let sushiIngredients = [];
  let riceCount = 0;
  let noriCount = 0;
  const MAX_RICE = 100;
  const MAX_NORI = 5;
  let currentMode = 'camera-rotate';
  let selectedObject = null;

  function init() {
    // Three.js setup
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('scene-container').appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);

    // Camera position
    camera.position.set(0, 5, 10);
    camera.lookAt(0, 0, 0);

    // Orbit controls
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Raycaster for object interaction
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    // Cannon.js world setup
    world = new CANNON.World();
    world.gravity.set(0, -9.82, 0);

    // Create a ground plane
    const groundShape = new CANNON.Plane();
    const groundBody = new CANNON.Body({ mass: 0 });
    groundBody.addShape(groundShape);
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
    world.addBody(groundBody);

    const groundGeometry = new THREE.PlaneGeometry(10, 10);
    const groundMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
    const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
    groundMesh.rotation.x = -Math.PI / 2;
    scene.add(groundMesh);

    // Event listeners
    document.getElementById('add-rice').addEventListener('click', addRice);
    document.getElementById('add-nori').addEventListener('click', addNori);
    document.getElementById('add-fish').addEventListener('click', addFish);
    document.getElementById('roll-sushi').addEventListener('click', rollSushi);

    // Toolbar event listeners
    document.querySelectorAll('.toolbar-button').forEach(button => {
      button.addEventListener('click', (e) => {
        setMode(e.currentTarget.id);
      });
    });

    renderer.domElement.addEventListener('mousedown', onMouseDown);
    renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('mouseup', onMouseUp);

    animate();
  }

  function setMode(mode) {
    currentMode = mode;
    document.querySelectorAll('.toolbar-button').forEach(button => {
      button.classList.remove('active');
    });
    document.getElementById(mode).classList.add('active');

    switch (mode) {
      case 'camera-rotate':
        controls.enableRotate = true;
        controls.enablePan = false;
        controls.enableZoom = false;
        break;
      case 'camera-pan':
        controls.enableRotate = false;
        controls.enablePan = true;
        controls.enableZoom = false;
        break;
      case 'camera-zoom':
        controls.enableRotate = false;
        controls.enablePan = false;
        controls.enableZoom = true;
        break;
      case 'interact-move':
      case 'interact-delete':
        controls.enableRotate = false;
        controls.enablePan = false;
        controls.enableZoom = false;
        break;
    }
  }

  function onMouseDown(event) {
    event.preventDefault();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(scene.children);

    if (intersects.length > 0) {
      if (currentMode === 'interact-move') {
        selectedObject = intersects[0].object;
      } else if (currentMode === 'interact-delete') {
        const deletedObject = intersects[0].object;
        const index = sushiIngredients.findIndex(item => item.mesh === deletedObject);
        if (index !== -1) {
          scene.remove(deletedObject);
          world.remove(sushiIngredients[index].body);
          sushiIngredients.splice(index, 1);
          if (deletedObject.userData.type === 'rice') {
            riceCount--;
            updateRiceCounter();
          } else if (deletedObject.userData.type === 'nori') {
            noriCount--;
            updateNoriCounter();
          }
        }
      }
    }
  }

  function onMouseMove(event) {
    if (currentMode === 'interact-move' && selectedObject) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObject(scene.getObjectByName('ground'));
      if (intersects.length > 0) {
        const point = intersects[0].point;
        selectedObject.position.set(point.x, point.y + 0.5, point.z);
        const index = sushiIngredients.findIndex(item => item.mesh === selectedObject);
        if (index !== -1) {
          sushiIngredients[index].body.position.copy(selectedObject.position);
        }
      }
    }
  }

  function onMouseUp() {
    selectedObject = null;
  }

  function addRice() {
    if (riceCount >= MAX_RICE) return;

    const riceGeometry = new THREE.SphereGeometry(0.05, 8, 8);
    const riceMaterial = new THREE.MeshStandardMaterial({ color: 0xfffaf0 });
    const riceMesh = new THREE.Mesh(riceGeometry, riceMaterial);
    riceMesh.userData.type = 'rice';

    const riceShape = new CANNON.Sphere(0.05);
    const riceBody = new CANNON.Body({
      mass: 0.01,
      shape: riceShape,
      position: new CANNON.Vec3(Math.random() * 2 - 1, 5, Math.random() * 2 - 1)
    });

    scene.add(riceMesh);
    world.addBody(riceBody);
    sushiIngredients.push({ mesh: riceMesh, body: riceBody, type: 'rice' });

    riceCount++;
    updateRiceCounter();

    // Add multiple rice grains at once
    if (riceCount % 10 === 0) {
      for (let i = 0; i < 9; i++) {
        setTimeout(addRice, i * 50);
      }
    }
  }

  function updateRiceCounter() {
    document.getElementById('rice-counter').textContent = `Rice grains: ${riceCount}`;
    const addRiceButton = document.getElementById('add-rice');
    addRiceButton.disabled = riceCount >= MAX_RICE;
  }

  function addNori() {
    if (noriCount >= MAX_NORI) return;

    const noriWidth = 1;
    const noriHeight = 0.01;
    const noriDepth = 1;
    const segments = 10;

    // Create flexible nori sheet using a series of connected boxes
    for (let i = 0; i < segments; i++) {
      const segmentWidth = noriWidth / segments;
      const segmentGeometry = new THREE.BoxGeometry(segmentWidth, noriHeight, noriDepth);
      const noriMaterial = new THREE.MeshStandardMaterial({ color: 0x1a4c1a });
      const noriMesh = new THREE.Mesh(segmentGeometry, noriMaterial);
      noriMesh.userData.type = 'nori';

      const noriShape = new CANNON.Box(new CANNON.Vec3(segmentWidth / 2, noriHeight / 2, noriDepth / 2));
      const noriBody = new CANNON.Body({
        mass: 0.05,
        shape: noriShape,
        position: new CANNON.Vec3((i - segments / 2) * segmentWidth, 5, Math.random() * 2 - 1)
      });

      if (i > 0) {
        const constraint = new CANNON.HingeConstraint(
          sushiIngredients[sushiIngredients.length - 1].body,
          noriBody,
          {
            pivotA: new CANNON.Vec3(segmentWidth / 2, 0, 0),
            pivotB: new CANNON.Vec3(-segmentWidth / 2, 0, 0),
            axisA: new CANNON.Vec3(0, 0, 1),
            axisB: new CANNON.Vec3(0, 0, 1)
          }
        );
        world.addConstraint(constraint);
      }

      scene.add(noriMesh);
      world.addBody(noriBody);
      sushiIngredients.push({ mesh: noriMesh, body: noriBody, type: 'nori' });
    }

    noriCount++;
    updateNoriCounter();
  }

  function updateNoriCounter() {
    document.getElementById('nori-counter').textContent = `Nori sheets: ${noriCount}`;
    const addNoriButton = document.getElementById('add-nori');
    addNoriButton.disabled = noriCount >= MAX_NORI;
  }

  function addFish() {
    const fishGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.2);
    const fishMaterial = new THREE.MeshStandardMaterial({ color: 0xfa8072 });
    const fishMesh = new THREE.Mesh(fishGeometry, fishMaterial);
    fishMesh.userData.type = 'fish';

    const fishShape = new CANNON.Box(new CANNON.Vec3(0.2, 0.05, 0.1));
    const fishBody = new CANNON.Body({
      mass: 0.3,
      shape: fishShape,
      position: new CANNON.Vec3(Math.random() * 2 - 1, 5, Math.random() * 2 - 1)
    });

    scene.add(fishMesh);
    world.addBody(fishBody);
    sushiIngredients.push({ mesh: fishMesh, body: fishBody, type: 'fish' });
  }

  function rollSushi() {
    const rollingForce = new CANNON.Vec3(5, 0, 0);
    sushiIngredients.forEach(ingredient => {
      ingredient.body.applyLocalForce(rollingForce, new CANNON.Vec3(0, 0, 0));
    });
  }

  function animate() {
    requestAnimationFrame(animate);
    world.step(timeStep);

    sushiIngredients.forEach(ingredient => {
      ingredient.mesh.position.copy(ingredient.body.position);
      ingredient.mesh.quaternion.copy(ingredient.body.quaternion);
    });

    controls.update();
    renderer.render(scene, camera);
  }

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  init();
  
  // Simulate adding some ingredients
  setTimeout(() => {
    for (let i = 0; i < 50; i++) {
      setTimeout(addRice, i * 50);
    }
    setTimeout(addNori, 2500);
    setTimeout(addFish, 3000);
  }, 1000);
</script>
</body></html>